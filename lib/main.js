(function() {
  var TYPES, color_code, color_name, effect_name, effect_names, effect_off, effect_on, isa_text, rainbow_color_names, rainbow_idx, _fn, _fn1, _ref, _rpr,
    __slice = [].slice,
    _this = this;

  this.constants = require('./constants');

  this.separator = ' ';

  this.depth_of_inspect = 20;

  TYPES = require('coffeenode-types');

  isa_text = TYPES.isa_text.bind(TYPES);

  _rpr = (require('util')).inspect;

  this.rpr = function(x) {
    return _rpr(x, {
      depth: this.depth_of_inspect
    });
  };

  this.get_output_method = function(target, options) {
    var R,
      _this = this;
    R = function() {
      var P, idx, last_idx, p, _i, _len;
      P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      last_idx = P.length - 1;
      for (idx = _i = 0, _len = P.length; _i < _len; idx = ++_i) {
        p = P[idx];
        target.write(isa_text(p) ? p : _this.rpr(p));
        if (idx !== last_idx) {
          target.write(_this.separator);
        }
      }
      return target.write('\n');
    };
    return R;
  };

  this.log = this.get_output_method(process.stderr);

  this.echo = this.get_output_method(process.stdout);

  this.clear_line_right = this.constants.clear_line_right;

  this.clear_line_left = this.constants.clear_line_left;

  this.clear_line = this.constants.clear_line;

  this.clear_below = this.constants.clear_below;

  this.clear_above = this.constants.clear_above;

  this.clear = this.constants.clear;

  this.goto = function(line_nr, column_nr) {
    if (line_nr == null) {
      line_nr = 1;
    }
    if (column_nr == null) {
      column_nr = 1;
    }
    return "\x1b[" + line_nr + ";" + column_nr + "H";
  };

  this.goto_column = function(column_nr) {
    if (column_nr == null) {
      column_nr = 1;
    }
    return "\x1b[" + column_nr + "G";
  };

  this.up = function(count) {
    if (count == null) {
      count = 1;
    }
    return "\x1b[" + count + "A";
  };

  this.down = function(count) {
    if (count == null) {
      count = 1;
    }
    return "\x1b[" + count + "B";
  };

  this.right = function(count) {
    if (count == null) {
      count = 1;
    }
    return "\x1b[" + count + "C";
  };

  this.left = function(count) {
    if (count == null) {
      count = 1;
    }
    return "\x1b[" + count + "D";
  };

  this.move = function(line_count, column_count) {
    return (line_count < 0 ? this.up(line_count) : this.down(line_count)) + (column_count < 0 ? this.left(column_count) : this.right(column_count));
  };

  this.ring_bell = function() {
    return process.stdout.write("\x07");
  };

  effect_names = {
    blink: 1,
    bold: 1,
    reverse: 1,
    underline: 1
  };

  _fn = function(effect_name, effect_on, effect_off) {
    return _this[effect_name] = function() {
      var P, R, idx, last_idx, p, _i, _len;
      P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      R = [effect_on];
      last_idx = P.length - 1;
      for (idx = _i = 0, _len = P.length; _i < _len; idx = ++_i) {
        p = P[idx];
        R.push(isa_text(p) ? p : _this.rpr(p));
        if (idx !== last_idx) {
          R.push(effect_on);
          R.push(_this.separator);
        }
      }
      R.push(effect_off);
      return R.join('');
    };
  };
  for (effect_name in effect_names) {
    effect_on = this.constants[effect_name];
    effect_off = this.constants['no_' + effect_name];
    _fn(effect_name, effect_on, effect_off);
  }

  _ref = this.constants['colors'];
  _fn1 = function(color_name, color_code) {
    return _this[color_name] = function() {
      var P, R, idx, last_idx, p, _i, _len;
      P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      R = [color_code];
      last_idx = P.length - 1;
      for (idx = _i = 0, _len = P.length; _i < _len; idx = ++_i) {
        p = P[idx];
        R.push(isa_text(p) ? p : _this.rpr(p));
        if (idx !== last_idx) {
          R.push(color_code);
          R.push(_this.separator);
        }
      }
      R.push(_this.constants['reset']);
      return R.join('');
    };
  };
  for (color_name in _ref) {
    color_code = _ref[color_name];
    _fn1(color_name, color_code);
  }

  rainbow_color_names = "blue tan cyan sepia indigo steel brown red olive lime crimson green plum orange pink\ngold yellow".split(/\s+/);

  rainbow_idx = -1;

  this.rainbow = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    rainbow_idx = (rainbow_idx + 1) % rainbow_color_names.length;
    return this[rainbow_color_names[rainbow_idx]].apply(this, P);
  };

}).call(this);
/****generated by https://github.com/loveencounterflow/larq****/